import React, { useState, useRef, useEffect } from 'react';

import { EditorState, KeyBindingUtil, convertToRaw, convertFromRaw, RichUtils, Modifier, convertFromHTML, SelectionState, CharacterMetadata } from 'draft-js';


import { makeStyles, styled, useTheme, withStyles, withTheme } from '@material-ui/core/styles';
import { Typography, Button, ButtonGroup, Container, Paper, Avatar, IconButton, Box } from "@material-ui/core";
import { InsertEmoticon } from "@material-ui/icons";
import { height } from '@material-ui/system';

import { withContext } from "./ContextProvider"
import Emoji, { emoji } from "./Emoji"
import classNames  from "classnames"

import {
  isMobile,
  isFirefox,
  isChrome,
  browserName,
  engineName,
} from "react-device-detect";
import { AvatarLogo } from './AvatarLogo';

const emojiRegexRGI = require('emoji-regex/es2015/RGI_Emoji.js');
// const emojiRegex = require('emoji-regex/es2015/index.js');
// const emojiRegexText = require('emoji-regex/es2015/text.js');
const emojiRegex = emojiRegexRGI()


const styleObj = function ({ breakpointsAttribute, ...theme }) {


  console.log(theme.palette.action.hover)

  return {
  

    emojiCss: (props) => {
      return {
      //  cursor: "pointer",
        borderWidth: 0,
        margin: 0,
        padding: 0,
        borderRadius: 0,
        //backgroundColor: theme.palette.background.default,
        display:"inline-block",
       // backgroundColor:"wheat",
        ...breakpointsAttribute(["fontSize", theme.textSizeArr]),
      
      }
    },
    emojiButtonCss: (props) => {
      return {
        margin: 1,
        cursor: "pointer",
        //backgroundColor: theme.palette.background.default,
        "&:hover": {
          backgroundColor: theme.palette.action.hover
        },
        "&:active": {
          backgroundColor: theme.palette.action.selected,
        }

      }
    },

  }
}



export default function createImagePlugin() {
  let externalES = null;
  let externalSetEditorState = null;



  function emojiStrategy(contentBlock, callback, contentState) {


    contentBlock.findEntityRanges(
      function (character) {
        const entityKey = character.getEntity();
        return (
          entityKey !== null &&
          contentState.getEntity(entityKey).getType() === "EMOJI"

        );
      },
      callback
    );
  };

  function taggingEmoji() {
    const [anchorKey, anchorOffset, focusKey, focusOffset, isBackward, hasfocus] = externalES.getSelection().toArray()
    const [anchorStartKey, anchorStartOffset, anchorFocusKey, anchorFocusOffset, isAnchorBackward, isAnchorFocused]
      = [!isBackward ? anchorKey : focusKey, !isBackward ? anchorOffset : focusOffset, isBackward ? anchorKey : focusKey, isBackward ? anchorOffset : focusOffset,]


    const oldSelection = externalES.getSelection();
    let newContent = externalES.getCurrentContent();
    let newSelection = externalES.getSelection();

    externalES.getCurrentContent().getBlocksAsArray().forEach(function (block) {

      const [blockKey, blockType, blockText, metaArr] = block.toArray()

      // metaArr.forEach(function (item, index) {
      //   const itemEntityKey = item.getEntity()


      //   if (itemEntityKey) {
      //     const entityType = newContent.getEntity(itemEntityKey).getType()
      //     if (entityType === "EMOJI") {

      //       newSelection = newSelection.merge({
      //         anchorKey: blockKey,
      //         anchorOffset: index,
      //         focusKey: blockKey,
      //         focusOffset: index + 1,
      //         isBackward: false,
      //         hasFocus: false,
      //       })
      //       newContent = Modifier.applyEntity(newContent, newSelection, null)
      //     }
      //   }
      // })



      let matchArr;
      while ((matchArr = emojiRegex.exec(blockText)) !== null) {

        const emojiKey = matchArr[0]
        const start = matchArr.index;
        const end = matchArr.index + matchArr[0].length;
        const contentLength = end - start;
        const contentFocusAt = anchorFocusOffset - start;
        // array.push(start)

        newSelection = newSelection.merge({
          anchorKey: blockKey,
          anchorOffset: start,
          focusKey: blockKey,
          focusOffset: start + emojiKey.length,
          isBackward: false,
          hasFocus: false,

        })

        newContent = newContent.createEntity("EMOJI", "IMMUTABLE", { url: emoji[emojiKey], symbol: emojiKey });
        const entityKey = newContent.getLastCreatedEntityKey();

        newContent = Modifier.applyEntity(newContent, newSelection, entityKey)
      }






    })






    externalES = EditorState.push(externalES, newContent, "insert-characters");
    externalES = EditorState.acceptSelection(externalES, oldSelection);
    return externalES
  }

  function insertEmoji(text) {

    const [anchorKey, anchorOffset, focusKey, focusOffset, isBackward, hasfocus] = externalES.getSelection().toArray()
    const [anchorStartKey, anchorStartOffset, anchorFocusKey, anchorFocusOffset, isAnchorBackward, isAnchorFocused]
      = [!isBackward ? anchorKey : focusKey, !isBackward ? anchorOffset : focusOffset, isBackward ? anchorKey : focusKey, isBackward ? anchorOffset : focusOffset,]


    let newContent = Modifier.replaceText(
      externalES.getCurrentContent(),
      externalES.getSelection(),
      text,
    )

    let newSelection = externalES.getSelection().merge({

      anchorKey: anchorStartKey,
      anchorOffset: anchorStartOffset + text.length,
      focusKey: anchorStartKey,
      focusOffset: anchorStartOffset + text.length,
      isBackward: false,
      hasFocus: true,
    })

    externalES = EditorState.push(externalES, newContent, "insert-characters");
    externalES = EditorState.acceptSelection(externalES, newSelection)

    externalSetEditorState(externalES)

  }

  function EmojiComp(props) {
    const { ctx, theme, contentState, entityKey, blockKey, offsetKey, start, end, decoratedText, classes } = props;

  

    return (
      <span 
        className={classes.emojiCss}
        style={{
          //  backgroundImage: emoji[item],
        }}
      >
        {/* <span //style={{ clipPath: "circle(0% at 50% 50%)", }}
        > */}
          {props.children}
        {/* </span> */}

      </span>
    )




  }

  function EmojiPanel({ theme, ctx, classes, ...props }) {



    const emojiArr1 = `
    ğŸ˜ƒ ğŸ˜„ ğŸ˜ ğŸ˜† ğŸ˜… ğŸ˜‚ â˜ºï¸ ğŸ˜Š ğŸ˜‡ ğŸ˜‰ ğŸ˜Œ ğŸ˜ ğŸ˜˜ ğŸ˜š ğŸ˜‹ ğŸ˜ ğŸ˜œ ğŸ˜ ğŸ˜ ğŸ˜’ ğŸ˜ ğŸ˜” â˜¹ï¸ ğŸ˜£ ğŸ˜– ğŸ˜« ğŸ˜© ğŸ˜¢ ğŸ˜­ ğŸ˜¤ ğŸ˜  ğŸ˜¡ ğŸ˜³ ğŸ˜± ğŸ˜¨ ğŸ˜° ğŸ˜¥ ğŸ˜“ ğŸ˜¶ ğŸ˜ ğŸ˜² ğŸ˜ª ğŸ˜µ ğŸ˜· ğŸ˜ˆ ğŸ‘¿ ğŸ‘¹ ğŸ‘º 
    ğŸ’© ğŸ‘» ğŸ’€ â˜ ï¸ ğŸ‘½ ğŸ‘¾ ğŸƒ ğŸ˜º ğŸ˜¸ ğŸ˜¹ ğŸ˜» ğŸ˜¼ ğŸ˜½ ğŸ™€ ğŸ˜¿ ğŸ˜¾ 
    `


    const emojiArr2 = `ğŸ‘‹ âœ‹ ğŸ‘Œ âœŒï¸ ğŸ‘ˆ ğŸ‘‰ ğŸ‘† ğŸ‘‡ â˜ï¸ ğŸ‘ ğŸ‘ âœŠ ğŸ‘Š ğŸ‘ ğŸ™Œ ğŸ‘ ğŸ™ âœï¸ ğŸ’… ğŸ’ª ğŸ‘£ ğŸ‘‚ ğŸ‘ƒ ğŸ‘€ ğŸ‘… ğŸ‘„ ğŸ’‹ 
    `

    const emojiArr3 = `ğŸ‘¶ ğŸ‘§ ğŸ§’ ğŸ‘¦ ğŸ‘© ğŸ§‘ ğŸ‘¨ ğŸ‘©â€ğŸ¦± ğŸ§‘â€ğŸ¦± ğŸ‘¨â€ğŸ¦± ğŸ‘©â€ğŸ¦° ğŸ§‘â€ğŸ¦° ğŸ‘¨â€ğŸ¦° ğŸ‘±â€â™€ï¸ ğŸ‘± ğŸ‘±â€â™‚ï¸ ğŸ‘©â€ğŸ¦³ ğŸ§‘â€ğŸ¦³ ğŸ‘¨â€ğŸ¦³ ğŸ‘©â€ğŸ¦² ğŸ§‘â€ğŸ¦² ğŸ‘¨â€ğŸ¦² ğŸ§” ğŸ‘µ ğŸ§“ ğŸ‘´ ğŸ‘² ğŸ‘³â€â™€ï¸ ğŸ‘³ ğŸ‘³â€â™‚ï¸ ğŸ§• ğŸ‘®â€â™€ï¸ ğŸ‘® ğŸ‘®â€â™‚ï¸ ğŸ‘·â€â™€ï¸ 
    ğŸ‘· ğŸ‘·â€â™‚ï¸ ğŸ’‚â€â™€ï¸ ğŸ’‚ ğŸ’‚â€â™‚ï¸ ğŸ•µï¸â€â™€ï¸ ğŸ•µï¸ ğŸ•µï¸â€â™‚ï¸ ğŸ‘©â€âš•ï¸ ğŸ§‘â€âš•ï¸ ğŸ‘¨â€âš•ï¸ ğŸ‘©â€ğŸŒ¾ ğŸ§‘â€ğŸŒ¾ ğŸ‘¨â€ğŸŒ¾ ğŸ‘©â€ğŸ³ ğŸ§‘â€ğŸ³ ğŸ‘¨â€ğŸ³ ğŸ‘©â€ğŸ“ ğŸ§‘â€ğŸ“ ğŸ‘¨â€ğŸ“ ğŸ‘©â€ğŸ¤ ğŸ§‘â€ğŸ¤ ğŸ‘¨â€ğŸ¤ ğŸ‘©â€ğŸ« ğŸ§‘â€ğŸ« ğŸ‘¨â€ğŸ« ğŸ‘©â€ğŸ­ ğŸ§‘â€ğŸ­ ğŸ‘¨â€ğŸ­ ğŸ‘©â€ğŸ’» ğŸ§‘â€ğŸ’» ğŸ‘¨â€ğŸ’» ğŸ‘©â€ğŸ’¼ ğŸ§‘â€ğŸ’¼ 
    ğŸ‘¨â€ğŸ’¼ ğŸ‘©â€ğŸ”§ ğŸ§‘â€ğŸ”§ ğŸ‘¨â€ğŸ”§ ğŸ‘©â€ğŸ”¬ ğŸ§‘â€ğŸ”¬ ğŸ‘¨â€ğŸ”¬ ğŸ‘©â€ğŸ¨ ğŸ§‘â€ğŸ¨ ğŸ‘¨â€ğŸ¨ ğŸ‘©â€ğŸš’ ğŸ§‘â€ğŸš’ ğŸ‘¨â€ğŸš’ ğŸ‘©â€âœˆï¸ ğŸ§‘â€âœˆï¸ ğŸ‘¨â€âœˆï¸ ğŸ‘©â€ğŸš€ ğŸ§‘â€ğŸš€ ğŸ‘¨â€ğŸš€ ğŸ‘©â€âš–ï¸ ğŸ§‘â€âš–ï¸ ğŸ‘¨â€âš–ï¸ ğŸ‘°â€â™€ï¸ ğŸ‘° ğŸ‘°â€â™‚ï¸ ğŸ¤µâ€â™€ï¸ ğŸ¤µ ğŸ¤µâ€â™‚ï¸ ğŸ‘¸ ğŸ¤´ ğŸ¥· ğŸ¦¸â€â™€ï¸ ğŸ¦¸ ğŸ¦¸â€â™‚ï¸ ğŸ¦¹â€â™€ï¸ ğŸ¦¹ 
    ğŸ¦¹â€â™‚ï¸ ğŸ¤¶ ğŸ§‘â€ğŸ„ ğŸ… ğŸ§™â€â™€ï¸ ğŸ§™ ğŸ§™â€â™‚ï¸ ğŸ§â€â™€ï¸ ğŸ§ ğŸ§â€â™‚ï¸ ğŸ§›â€â™€ï¸ ğŸ§› ğŸ§›â€â™‚ï¸ ğŸ§Ÿâ€â™€ï¸ ğŸ§Ÿ ğŸ§Ÿâ€â™‚ï¸ ğŸ§â€â™€ï¸ ğŸ§ ğŸ§â€â™‚ï¸ ğŸ§œâ€â™€ï¸ ğŸ§œ ğŸ§œâ€â™‚ï¸ ğŸ§šâ€â™€ï¸ ğŸ§š ğŸ§šâ€â™‚ï¸ ğŸ‘¼ ğŸ¤° ğŸ¤± ğŸ‘©â€ğŸ¼ ğŸ§‘â€ğŸ¼ ğŸ‘¨â€ğŸ¼ ğŸ™‡â€â™€ï¸ ğŸ™‡ ğŸ™‡â€â™‚ï¸ ğŸ’â€â™€ï¸ ğŸ’ ğŸ’â€â™‚ï¸ ğŸ™…â€â™€ï¸ ğŸ™… ğŸ™…â€â™‚ï¸ ğŸ™†â€â™€ï¸ ğŸ™† ğŸ™†â€â™‚ï¸ 
    ğŸ™‹â€â™€ï¸ ğŸ™‹ ğŸ™‹â€â™‚ï¸ ğŸ§â€â™€ï¸ ğŸ§ ğŸ§â€â™‚ï¸ ğŸ¤¦â€â™€ï¸ ğŸ¤¦ ğŸ¤¦â€â™‚ï¸ ğŸ¤·â€â™€ï¸ ğŸ¤· ğŸ¤·â€â™‚ï¸ ğŸ™â€â™€ï¸ ğŸ™ ğŸ™â€â™‚ï¸ ğŸ™â€â™€ï¸ ğŸ™ ğŸ™â€â™‚ï¸ ğŸ’‡â€â™€ï¸ ğŸ’‡ ğŸ’‡â€â™‚ï¸ ğŸ’†â€â™€ï¸ ğŸ’† ğŸ’†â€â™‚ï¸ ğŸ§–â€â™€ï¸ ğŸ§– ğŸ§–â€â™‚ï¸ ğŸ’… ğŸ¤³ ğŸ’ƒ ğŸ•º ğŸ‘¯â€â™€ï¸ ğŸ‘¯ ğŸ‘¯â€â™‚ï¸ ğŸ•´ ğŸ‘©â€ğŸ¦½ ğŸ§‘â€ğŸ¦½ ğŸ‘¨â€ğŸ¦½ ğŸ‘©â€ğŸ¦¼ ğŸ§‘â€ğŸ¦¼ ğŸ‘¨â€ğŸ¦¼ 
    ğŸš¶â€â™€ï¸ ğŸš¶ ğŸš¶â€â™‚ï¸ ğŸ‘©â€ğŸ¦¯ ğŸ§‘â€ğŸ¦¯ ğŸ‘¨â€ğŸ¦¯ ğŸ§â€â™€ï¸ ğŸ§ ğŸ§â€â™‚ï¸ ğŸƒâ€â™€ï¸ ğŸƒ ğŸƒâ€â™‚ï¸ ğŸ§â€â™€ï¸ ğŸ§ ğŸ§â€â™‚ï¸ ğŸ‘­ ğŸ§‘â€ğŸ¤â€ğŸ§‘ ğŸ‘¬ ğŸ‘« ğŸ‘©â€â¤ï¸â€ğŸ‘© ğŸ’‘ ğŸ‘¨â€â¤ï¸â€ğŸ‘¨ ğŸ‘©â€â¤ï¸â€ğŸ‘¨ ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘© ğŸ’ ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨ ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨ ğŸ‘ª ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ 
    ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘§ ğŸ‘©â€ğŸ‘©â€ğŸ‘¦ ğŸ‘©â€ğŸ‘©â€ğŸ‘§ ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ğŸ‘©â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ ğŸ‘¨â€ğŸ‘¦ ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ ğŸ‘¨â€ğŸ‘§ ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦ ğŸ‘¨â€ğŸ‘§â€ğŸ‘§ ğŸ‘©â€ğŸ‘¦ ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ ğŸ‘©â€ğŸ‘§ ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ğŸ‘©â€ğŸ‘§â€ğŸ‘§ ğŸ—£ ğŸ‘¤ ğŸ‘¥ ğŸ«‚ 
    `




    let match;
    const arr = [];
    while (match = emojiRegex.exec(emojiArr3)) {
      const emoji = match[0];
      arr.push(emoji)
      //  console.log(`Matched sequence ${emoji} â€” code points: ${[...emoji].length}`);
    }
    const allClassNames = classNames({
      [classes.emojiCss]:true,
      [classes.emojiButtonCss]:true

    })



    return (
      <div style={{ ...props.style, display: "flex", flexWrap: "wrap", }}>

        {arr.map(item => {

          return (
            <button key={item} //disableRipple
              className={allClassNames}
              onClick={function () {
                insertEmoji(item)
              }}

            >
              {/* <span
                className={classes.emojiCss}
                style={{
                  // backgroundImage: emoji[item],
                }}
              >
                <span //style={{ clipPath: "circle(0% at 50% 50%)", }}
                > */}
                  {item}
                {/* </span> */}

              {/* </span> */}



            </button>
          )
        })}
      </div >
    )






  }

  return {

    emojiPlugin: {
      onChange: function (editorState, { setEditorState }) {
        externalES = editorState
        externalSetEditorState = setEditorState
        externalES = taggingEmoji()

        return externalES
      },

      decorators: [{

        strategy: emojiStrategy,
        component: withStyles(styleObj, { withTheme: true })(withContext(EmojiComp))                       //withTheme(withContext(EmojiComp))
      }],
    },

    EmojiPanel: withStyles(styleObj, { withTheme: true })(withContext(EmojiPanel))


  }


}